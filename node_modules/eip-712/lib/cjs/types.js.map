{"version":3,"sources":["../../src/types.ts"],"names":["TYPE_REGEX","ARRAY_REGEX","BYTES_REGEX","NUMBER_REGEX","STATIC_TYPES","TYPE","type","context","isValidType","branch","types","EIP_712_TYPE","name","EIP_712_DOMAIN_TYPE","version","chainId","verifyingContract","salt","EIP_712_TYPED_DATA_TYPE","EIP712Domain","primaryType","domain","message","includes","match","innerType","bytesMatch","length","Number","numberMatch"],"mappings":"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","sourcesContent":["import {\n  array,\n  intersection,\n  number,\n  object,\n  optional,\n  pattern,\n  record,\n  refinement,\n  string,\n  StructType,\n  type,\n  union\n} from 'superstruct';\n\nexport const TYPE_REGEX = /^\\w+/;\nexport const ARRAY_REGEX = /^(.*)\\[([0-9]*?)]$/;\nexport const BYTES_REGEX = /^bytes([0-9]{1,2})$/;\nexport const NUMBER_REGEX = /^u?int([0-9]{0,3})$/;\n\nexport const STATIC_TYPES = ['address', 'bool', 'bytes', 'string'];\n\nconst TYPE = refinement(string(), 'Type', (type, context) => {\n  return isValidType(context.branch[0].types, type);\n});\n\nexport const EIP_712_TYPE = object({\n  name: string(),\n  type: TYPE\n});\n\n/**\n * A single type, as part of a struct. The `type` field can be any of the EIP-712 supported types. Currently those are:\n * - Atomic types: bytes1..32, uint8..256, int8..256, bool, address\n * - Dynamic types: bytes, string\n * - Reference types: array type (e.g. uint8[], SomeStruct[]), struct type (e.g. SomeStruct)\n *\n * Note that the `uint` and `int` aliases like in Solidity, and fixed point numbers are not supported by the EIP-712\n * standard.\n */\nexport type EIP712Type = StructType<typeof EIP_712_TYPE>;\n\nexport const EIP_712_DOMAIN_TYPE = object({\n  name: optional(string()),\n  version: optional(string()),\n  chainId: optional(union([string(), number()])),\n  verifyingContract: optional(pattern(string(), /^0x[0-9a-z]{40}$/i)),\n  salt: optional(union([array(number()), pattern(string(), /^0x[0-9a-z]{64}$/i)]))\n});\n\n/**\n * The EIP712 domain struct. Any of these fields are optional, but it must contain at least one field.\n */\nexport type EIP712Domain = StructType<typeof EIP_712_DOMAIN_TYPE>;\n\nexport const EIP_712_TYPED_DATA_TYPE = object({\n  types: intersection([type({ EIP712Domain: array(EIP_712_TYPE) }), record(string(), array(EIP_712_TYPE))]),\n  primaryType: string(),\n  domain: EIP_712_DOMAIN_TYPE,\n  message: object()\n});\n\n/**\n * The complete typed data, with all the structs, domain data, primary type of the message, and the message itself.\n */\nexport type TypedData = StructType<typeof EIP_712_TYPED_DATA_TYPE>;\n\n/**\n * Checks if a type is valid with the given `typedData`. The following types are valid:\n * - Atomic types: bytes1..32, uint8..256, int8..256, bool, address\n * - Dynamic types: bytes, string\n * - Reference types: array type (e.g. uint8[], SomeStruct[]), struct type (e.g. SomeStruct)\n *\n * The `uint` and `int` aliases like in Solidity are not supported. Fixed point numbers are not supported.\n *\n * @param {Record<string, unknown>} types\n * @param {string} type\n * @return {boolean}\n */\nexport const isValidType = (types: Record<string, unknown>, type: string): boolean => {\n  if (STATIC_TYPES.includes(type as string)) {\n    return true;\n  }\n\n  if (types[type]) {\n    return true;\n  }\n\n  if (type.match(ARRAY_REGEX)) {\n    const match = type.match(TYPE_REGEX);\n    if (match) {\n      const innerType = match[0];\n      return isValidType(types, innerType);\n    }\n  }\n\n  const bytesMatch = type.match(BYTES_REGEX);\n  if (bytesMatch) {\n    const length = Number(bytesMatch[1]);\n    if (length >= 1 && length <= 32) {\n      return true;\n    }\n  }\n\n  const numberMatch = type.match(NUMBER_REGEX);\n  if (numberMatch) {\n    const length = Number(numberMatch[1]);\n    if (length >= 8 && length <= 256 && length % 8 === 0) {\n      return true;\n    }\n  }\n\n  return false;\n};\n"],"file":"types.js"}