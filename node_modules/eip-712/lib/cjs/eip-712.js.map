{"version":3,"sources":["../../src/eip-712.ts"],"names":["EIP_191_PREFIX","Buffer","from","getDependencies","typedData","type","dependencies","Error","match","TYPE_REGEX","actualType","includes","types","reduce","previous","filter","dependency","encodeType","primary","sort","map","name","join","getTypeHash","encodeValue","data","ARRAY_REGEX","arrayType","length","Number","undefined","Array","isArray","encodedData","item","values","getStructHash","isBuffer","encodeData","field","value","encodedValue","getMessage","hash","message","concat","domain","primaryType","asArray","array"],"mappings":"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","sourcesContent":["import { ARRAY_REGEX, TYPE_REGEX, TypedData } from './types';\nimport { keccak256, toBuffer, validateTypedData, encode } from './utils';\n\nconst EIP_191_PREFIX = Buffer.from('1901', 'hex');\n\n/**\n * Get the dependencies of a struct type. If a struct has the same dependency multiple times, it's only included once\n * in the resulting array.\n *\n * @param {TypedData} typedData\n * @param {string} type\n * @param {string[]} [dependencies]\n * @return {string[]}\n */\nexport const getDependencies = (typedData: TypedData, type: string, dependencies: string[] = []): string[] => {\n  // `getDependencies` is called by most other functions, so we validate the JSON schema here\n  if (!validateTypedData(typedData)) {\n    throw new Error('Typed data does not match JSON schema');\n  }\n\n  const match = type.match(TYPE_REGEX)!;\n  const actualType = match[0];\n  if (dependencies.includes(actualType)) {\n    return dependencies;\n  }\n\n  if (!typedData.types[actualType]) {\n    return dependencies;\n  }\n\n  return [\n    actualType,\n    ...typedData.types[actualType].reduce<string[]>(\n      (previous, type) => [\n        ...previous,\n        ...getDependencies(typedData, type.type, previous).filter((dependency) => !previous.includes(dependency))\n      ],\n      []\n    )\n  ];\n};\n\n/**\n * Encode a type to a string. All dependant types are alphabetically sorted.\n *\n * @param {TypedData} typedData\n * @param {string} type\n * @return {string}\n */\nexport const encodeType = (typedData: TypedData, type: string): string => {\n  const [primary, ...dependencies] = getDependencies(typedData, type);\n  const types = [primary, ...dependencies.sort()];\n\n  return types\n    .map((dependency) => {\n      return `${dependency}(${typedData.types[dependency].map((type) => `${type.type} ${type.name}`)})`;\n    })\n    .join('');\n};\n\n/**\n * Get a type string as hash.\n *\n * @param {TypedData} typedData\n * @param {string} type\n * @return {BufferEncoding}\n */\nexport const getTypeHash = (typedData: TypedData, type: string): Buffer => {\n  return keccak256(encodeType(typedData, type), 'utf8');\n};\n\n/**\n * Encodes a single value to an ABI serialisable string, number or Buffer. Returns the data as tuple, which consists of\n * an array of ABI compatible types, and an array of corresponding values.\n *\n * @param {TypedData} typedData\n * @param {string} type\n * @param {any} data\n * @returns {[string[], (string | Buffer | number)[]}\n */\nconst encodeValue = (typedData: TypedData, type: string, data: unknown): [string, string | Buffer | number] => {\n  const match = type.match(ARRAY_REGEX);\n\n  // Checks for array types\n  if (match) {\n    const arrayType = match[1];\n    const length = Number(match[2]) || undefined;\n\n    if (!Array.isArray(data)) {\n      throw new Error('Cannot encode data: value is not of array type');\n    }\n\n    if (length && data.length !== length) {\n      throw new Error(`Cannot encode data: expected length of ${length}, but got ${data.length}`);\n    }\n\n    const encodedData = data.map((item) => encodeValue(typedData, arrayType, item));\n    const types = encodedData.map((item) => item[0]);\n    const values = encodedData.map((item) => item[1]);\n\n    return ['bytes32', keccak256(encode(types, values))];\n  }\n\n  if (typedData.types[type]) {\n    return ['bytes32', getStructHash(typedData, type, data as Record<string, unknown>)];\n  }\n\n  // Strings and arbitrary byte arrays are hashed to bytes32\n  if (type === 'string') {\n    return ['bytes32', keccak256(data as string, 'utf8')];\n  }\n\n  if (type === 'bytes') {\n    return ['bytes32', keccak256(Buffer.isBuffer(data) ? data : toBuffer(data as string), 'hex')];\n  }\n\n  return [type, data as string];\n};\n\n/**\n * Encode the data to an ABI encoded Buffer. The data should be a key -> value object with all the required values. All\n * dependant types are automatically encoded.\n *\n * @param {TypedData} typedData\n * @param {string} type\n * @param {Record<string, any>} data\n * @return {Buffer}\n */\nexport const encodeData = (typedData: TypedData, type: string, data: Record<string, unknown>): Buffer => {\n  const [types, values] = typedData.types[type].reduce<[string[], unknown[]]>(\n    ([types, values], field) => {\n      if (data[field.name] === undefined || data[field.name] === null) {\n        throw new Error(`Cannot encode data: missing data for '${field.name}'`);\n      }\n\n      const value = data[field.name];\n      const [type, encodedValue] = encodeValue(typedData, field.type, value);\n\n      return [\n        [...types, type],\n        [...values, encodedValue]\n      ];\n    },\n    [['bytes32'], [getTypeHash(typedData, type)]]\n  );\n\n  return encode(types, values);\n};\n\n/**\n * Get encoded data as a hash. The data should be a key -> value object with all the required values. All dependant\n * types are automatically encoded.\n *\n * @param {TypedData} typedData\n * @param {string} type\n * @param {Record<string, any>} data\n * @return {Buffer}\n */\nexport const getStructHash = (typedData: TypedData, type: string, data: Record<string, unknown>): Buffer => {\n  return keccak256(encodeData(typedData, type, data));\n};\n\n/**\n * Get the EIP-191 encoded message to sign, from the typedData object. If `hash` is enabled, the message will be hashed\n * with Keccak256.\n *\n * @param {TypedData} typedData\n * @param {boolean} hash\n * @return {Buffer}\n */\nexport const getMessage = (typedData: TypedData, hash?: boolean): Buffer => {\n  const message = Buffer.concat([\n    EIP_191_PREFIX,\n    getStructHash(typedData, 'EIP712Domain', typedData.domain as Record<string, unknown>),\n    getStructHash(typedData, typedData.primaryType, typedData.message)\n  ]);\n\n  if (hash) {\n    return keccak256(message);\n  }\n\n  return message;\n};\n\n/**\n * Get the typed data as array. This can be useful for encoding the typed data with the contract ABI.\n *\n * @param {TypedData} typedData\n * @param {string} [type]\n * @param data\n * @return {any[]}\n */\nexport const asArray = (\n  typedData: TypedData,\n  type: string = typedData.primaryType,\n  data: Record<string, unknown> = typedData.message\n): unknown[] => {\n  if (!validateTypedData(typedData)) {\n    throw new Error('Typed data does not match JSON schema');\n  }\n\n  if (!typedData.types[type]) {\n    throw new Error('Cannot get data as array: type does not exist');\n  }\n\n  return typedData.types[type].reduce<unknown[]>((array, { name, type }) => {\n    if (typedData.types[type]) {\n      if (!data[name]) {\n        throw new Error(`Cannot get data as array: missing data for '${name}'`);\n      }\n\n      return [...array, asArray(typedData, type, data[name] as Record<string, unknown>)];\n    }\n\n    const value = data[name];\n    return [...array, value];\n  }, []);\n};\n"],"file":"eip-712.js"}