{"version":3,"sources":["../../src/types.ts"],"names":["array","intersection","number","object","optional","pattern","record","refinement","string","type","union","TYPE_REGEX","ARRAY_REGEX","BYTES_REGEX","NUMBER_REGEX","STATIC_TYPES","TYPE","context","isValidType","branch","types","EIP_712_TYPE","name","EIP_712_DOMAIN_TYPE","version","chainId","verifyingContract","salt","EIP_712_TYPED_DATA_TYPE","EIP712Domain","primaryType","domain","message","includes","match","innerType","bytesMatch","length","Number","numberMatch"],"mappings":"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","sourcesContent":["import {\n  array,\n  intersection,\n  number,\n  object,\n  optional,\n  pattern,\n  record,\n  refinement,\n  string,\n  StructType,\n  type,\n  union\n} from 'superstruct';\n\nexport const TYPE_REGEX = /^\\w+/;\nexport const ARRAY_REGEX = /^(.*)\\[([0-9]*?)]$/;\nexport const BYTES_REGEX = /^bytes([0-9]{1,2})$/;\nexport const NUMBER_REGEX = /^u?int([0-9]{0,3})$/;\n\nexport const STATIC_TYPES = ['address', 'bool', 'bytes', 'string'];\n\nconst TYPE = refinement(string(), 'Type', (type, context) => {\n  return isValidType(context.branch[0].types, type);\n});\n\nexport const EIP_712_TYPE = object({\n  name: string(),\n  type: TYPE\n});\n\n/**\n * A single type, as part of a struct. The `type` field can be any of the EIP-712 supported types. Currently those are:\n * - Atomic types: bytes1..32, uint8..256, int8..256, bool, address\n * - Dynamic types: bytes, string\n * - Reference types: array type (e.g. uint8[], SomeStruct[]), struct type (e.g. SomeStruct)\n *\n * Note that the `uint` and `int` aliases like in Solidity, and fixed point numbers are not supported by the EIP-712\n * standard.\n */\nexport type EIP712Type = StructType<typeof EIP_712_TYPE>;\n\nexport const EIP_712_DOMAIN_TYPE = object({\n  name: optional(string()),\n  version: optional(string()),\n  chainId: optional(union([string(), number()])),\n  verifyingContract: optional(pattern(string(), /^0x[0-9a-z]{40}$/i)),\n  salt: optional(union([array(number()), pattern(string(), /^0x[0-9a-z]{64}$/i)]))\n});\n\n/**\n * The EIP712 domain struct. Any of these fields are optional, but it must contain at least one field.\n */\nexport type EIP712Domain = StructType<typeof EIP_712_DOMAIN_TYPE>;\n\nexport const EIP_712_TYPED_DATA_TYPE = object({\n  types: intersection([type({ EIP712Domain: array(EIP_712_TYPE) }), record(string(), array(EIP_712_TYPE))]),\n  primaryType: string(),\n  domain: EIP_712_DOMAIN_TYPE,\n  message: object()\n});\n\n/**\n * The complete typed data, with all the structs, domain data, primary type of the message, and the message itself.\n */\nexport type TypedData = StructType<typeof EIP_712_TYPED_DATA_TYPE>;\n\n/**\n * Checks if a type is valid with the given `typedData`. The following types are valid:\n * - Atomic types: bytes1..32, uint8..256, int8..256, bool, address\n * - Dynamic types: bytes, string\n * - Reference types: array type (e.g. uint8[], SomeStruct[]), struct type (e.g. SomeStruct)\n *\n * The `uint` and `int` aliases like in Solidity are not supported. Fixed point numbers are not supported.\n *\n * @param {Record<string, unknown>} types\n * @param {string} type\n * @return {boolean}\n */\nexport const isValidType = (types: Record<string, unknown>, type: string): boolean => {\n  if (STATIC_TYPES.includes(type as string)) {\n    return true;\n  }\n\n  if (types[type]) {\n    return true;\n  }\n\n  if (type.match(ARRAY_REGEX)) {\n    const match = type.match(TYPE_REGEX);\n    if (match) {\n      const innerType = match[0];\n      return isValidType(types, innerType);\n    }\n  }\n\n  const bytesMatch = type.match(BYTES_REGEX);\n  if (bytesMatch) {\n    const length = Number(bytesMatch[1]);\n    if (length >= 1 && length <= 32) {\n      return true;\n    }\n  }\n\n  const numberMatch = type.match(NUMBER_REGEX);\n  if (numberMatch) {\n    const length = Number(numberMatch[1]);\n    if (length >= 8 && length <= 256 && length % 8 === 0) {\n      return true;\n    }\n  }\n\n  return false;\n};\n"],"file":"types.js"}