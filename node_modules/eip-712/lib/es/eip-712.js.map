{"version":3,"sources":["../../src/eip-712.ts"],"names":["ARRAY_REGEX","TYPE_REGEX","keccak256","toBuffer","validateTypedData","encode","EIP_191_PREFIX","Buffer","from","getDependencies","typedData","type","dependencies","Error","match","actualType","includes","types","reduce","previous","filter","dependency","encodeType","primary","sort","map","name","join","getTypeHash","encodeValue","data","arrayType","length","Number","undefined","Array","isArray","encodedData","item","values","getStructHash","isBuffer","encodeData","field","value","encodedValue","getMessage","hash","message","concat","domain","primaryType","asArray","array"],"mappings":"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","sourcesContent":["import { ARRAY_REGEX, TYPE_REGEX, TypedData } from './types';\nimport { keccak256, toBuffer, validateTypedData, encode } from './utils';\n\nconst EIP_191_PREFIX = Buffer.from('1901', 'hex');\n\n/**\n * Get the dependencies of a struct type. If a struct has the same dependency multiple times, it's only included once\n * in the resulting array.\n *\n * @param {TypedData} typedData\n * @param {string} type\n * @param {string[]} [dependencies]\n * @return {string[]}\n */\nexport const getDependencies = (typedData: TypedData, type: string, dependencies: string[] = []): string[] => {\n  // `getDependencies` is called by most other functions, so we validate the JSON schema here\n  if (!validateTypedData(typedData)) {\n    throw new Error('Typed data does not match JSON schema');\n  }\n\n  const match = type.match(TYPE_REGEX)!;\n  const actualType = match[0];\n  if (dependencies.includes(actualType)) {\n    return dependencies;\n  }\n\n  if (!typedData.types[actualType]) {\n    return dependencies;\n  }\n\n  return [\n    actualType,\n    ...typedData.types[actualType].reduce<string[]>(\n      (previous, type) => [\n        ...previous,\n        ...getDependencies(typedData, type.type, previous).filter((dependency) => !previous.includes(dependency))\n      ],\n      []\n    )\n  ];\n};\n\n/**\n * Encode a type to a string. All dependant types are alphabetically sorted.\n *\n * @param {TypedData} typedData\n * @param {string} type\n * @return {string}\n */\nexport const encodeType = (typedData: TypedData, type: string): string => {\n  const [primary, ...dependencies] = getDependencies(typedData, type);\n  const types = [primary, ...dependencies.sort()];\n\n  return types\n    .map((dependency) => {\n      return `${dependency}(${typedData.types[dependency].map((type) => `${type.type} ${type.name}`)})`;\n    })\n    .join('');\n};\n\n/**\n * Get a type string as hash.\n *\n * @param {TypedData} typedData\n * @param {string} type\n * @return {BufferEncoding}\n */\nexport const getTypeHash = (typedData: TypedData, type: string): Buffer => {\n  return keccak256(encodeType(typedData, type), 'utf8');\n};\n\n/**\n * Encodes a single value to an ABI serialisable string, number or Buffer. Returns the data as tuple, which consists of\n * an array of ABI compatible types, and an array of corresponding values.\n *\n * @param {TypedData} typedData\n * @param {string} type\n * @param {any} data\n * @returns {[string[], (string | Buffer | number)[]}\n */\nconst encodeValue = (typedData: TypedData, type: string, data: unknown): [string, string | Buffer | number] => {\n  const match = type.match(ARRAY_REGEX);\n\n  // Checks for array types\n  if (match) {\n    const arrayType = match[1];\n    const length = Number(match[2]) || undefined;\n\n    if (!Array.isArray(data)) {\n      throw new Error('Cannot encode data: value is not of array type');\n    }\n\n    if (length && data.length !== length) {\n      throw new Error(`Cannot encode data: expected length of ${length}, but got ${data.length}`);\n    }\n\n    const encodedData = data.map((item) => encodeValue(typedData, arrayType, item));\n    const types = encodedData.map((item) => item[0]);\n    const values = encodedData.map((item) => item[1]);\n\n    return ['bytes32', keccak256(encode(types, values))];\n  }\n\n  if (typedData.types[type]) {\n    return ['bytes32', getStructHash(typedData, type, data as Record<string, unknown>)];\n  }\n\n  // Strings and arbitrary byte arrays are hashed to bytes32\n  if (type === 'string') {\n    return ['bytes32', keccak256(data as string, 'utf8')];\n  }\n\n  if (type === 'bytes') {\n    return ['bytes32', keccak256(Buffer.isBuffer(data) ? data : toBuffer(data as string), 'hex')];\n  }\n\n  return [type, data as string];\n};\n\n/**\n * Encode the data to an ABI encoded Buffer. The data should be a key -> value object with all the required values. All\n * dependant types are automatically encoded.\n *\n * @param {TypedData} typedData\n * @param {string} type\n * @param {Record<string, any>} data\n * @return {Buffer}\n */\nexport const encodeData = (typedData: TypedData, type: string, data: Record<string, unknown>): Buffer => {\n  const [types, values] = typedData.types[type].reduce<[string[], unknown[]]>(\n    ([types, values], field) => {\n      if (data[field.name] === undefined || data[field.name] === null) {\n        throw new Error(`Cannot encode data: missing data for '${field.name}'`);\n      }\n\n      const value = data[field.name];\n      const [type, encodedValue] = encodeValue(typedData, field.type, value);\n\n      return [\n        [...types, type],\n        [...values, encodedValue]\n      ];\n    },\n    [['bytes32'], [getTypeHash(typedData, type)]]\n  );\n\n  return encode(types, values);\n};\n\n/**\n * Get encoded data as a hash. The data should be a key -> value object with all the required values. All dependant\n * types are automatically encoded.\n *\n * @param {TypedData} typedData\n * @param {string} type\n * @param {Record<string, any>} data\n * @return {Buffer}\n */\nexport const getStructHash = (typedData: TypedData, type: string, data: Record<string, unknown>): Buffer => {\n  return keccak256(encodeData(typedData, type, data));\n};\n\n/**\n * Get the EIP-191 encoded message to sign, from the typedData object. If `hash` is enabled, the message will be hashed\n * with Keccak256.\n *\n * @param {TypedData} typedData\n * @param {boolean} hash\n * @return {Buffer}\n */\nexport const getMessage = (typedData: TypedData, hash?: boolean): Buffer => {\n  const message = Buffer.concat([\n    EIP_191_PREFIX,\n    getStructHash(typedData, 'EIP712Domain', typedData.domain as Record<string, unknown>),\n    getStructHash(typedData, typedData.primaryType, typedData.message)\n  ]);\n\n  if (hash) {\n    return keccak256(message);\n  }\n\n  return message;\n};\n\n/**\n * Get the typed data as array. This can be useful for encoding the typed data with the contract ABI.\n *\n * @param {TypedData} typedData\n * @param {string} [type]\n * @param data\n * @return {any[]}\n */\nexport const asArray = (\n  typedData: TypedData,\n  type: string = typedData.primaryType,\n  data: Record<string, unknown> = typedData.message\n): unknown[] => {\n  if (!validateTypedData(typedData)) {\n    throw new Error('Typed data does not match JSON schema');\n  }\n\n  if (!typedData.types[type]) {\n    throw new Error('Cannot get data as array: type does not exist');\n  }\n\n  return typedData.types[type].reduce<unknown[]>((array, { name, type }) => {\n    if (typedData.types[type]) {\n      if (!data[name]) {\n        throw new Error(`Cannot get data as array: missing data for '${name}'`);\n      }\n\n      return [...array, asArray(typedData, type, data[name] as Record<string, unknown>)];\n    }\n\n    const value = data[name];\n    return [...array, value];\n  }, []);\n};\n"],"file":"eip-712.js"}