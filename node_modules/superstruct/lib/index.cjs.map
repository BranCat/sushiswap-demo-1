{"version":3,"file":"index.cjs","sources":["../src/utils.ts","../src/struct.ts","../src/coercions.ts","../src/refinements.ts","../src/types.ts"],"sourcesContent":["import { Struct, StructResult, StructFailure, StructContext } from './struct'\n\nexport type StructRecord<T> = Record<string, Struct<T>>\nexport type StructTuple<T> = { [K in keyof T]: Struct<T[K]> }\n\n/**\n * Convert a validation result to an iterable of failures.\n */\n\nexport function* toFailures(\n  result: StructResult,\n  context: StructContext\n): IterableIterator<StructFailure> {\n  if (result === true) {\n    // yield nothing\n  } else if (result === false) {\n    yield context.fail()\n  } else {\n    yield* result\n  }\n}\n\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\n\nexport function iteratorShift<T>(input: Iterator<T>): T | undefined {\n  const { done, value } = input.next()\n  return done ? undefined : value\n}\n","import { toFailures, iteratorShift } from './utils'\n\n/**\n * `Struct` objects encapsulate the schema for a specific data type (with\n * optional coercion). You can then use the `assert`, `is` or `validate` helpers\n * to validate unknown data against a struct.\n */\n\nexport class Struct<T, S = any> {\n  type: string\n  schema: S\n  coercer: (value: unknown) => unknown\n  validator: (value: unknown, context: StructContext) => StructResult\n  refiner: (value: T, context: StructContext) => StructResult\n\n  constructor(props: {\n    type: Struct<T>['type']\n    schema: S\n    coercer?: Struct<T>['coercer']\n    validator?: Struct<T>['validator']\n    refiner?: Struct<T>['refiner']\n  }) {\n    const {\n      type,\n      schema,\n      coercer = (value: unknown) => value,\n      validator = () => [],\n      refiner = () => [],\n    } = props\n    this.type = type\n    this.schema = schema\n    this.coercer = coercer\n    this.validator = validator\n    this.refiner = refiner\n  }\n}\n\n/**\n * `StructError` objects are thrown (or returned) by Superstruct when its\n * validation fails. The error represents the first error encountered during\n * validation. But they also have an `error.failures` property that holds\n * information for all of the failures encountered.\n */\n\nexport class StructError extends TypeError {\n  value: any\n  type: string\n  path: Array<number | string>\n  branch: Array<any>\n  failures: () => Array<StructFailure>;\n  [key: string]: any\n\n  constructor(\n    failure: StructFailure,\n    moreFailures: IterableIterator<StructFailure>\n  ) {\n    const { path, value, type, branch, ...rest } = failure\n    const message = `Expected a value of type \\`${type}\\`${\n      path.length ? ` for \\`${path.join('.')}\\`` : ''\n    } but received \\`${JSON.stringify(value)}\\`.`\n\n    let failuresResult: Array<StructFailure> | undefined\n    function failures(): Array<StructFailure> {\n      if (!failuresResult) {\n        failuresResult = [failure, ...moreFailures]\n      }\n      return failuresResult\n    }\n\n    super(message)\n    this.value = value\n    Object.assign(this, rest)\n    this.type = type\n    this.path = path\n    this.branch = branch\n    this.failures = failures\n    this.stack = new Error().stack\n    ;(this as any).__proto__ = StructError.prototype\n  }\n}\n\n/**\n * A `StructContext` contains information about the current value being\n * validated as well as helper functions for failures and recursive validating.\n */\n\nexport type StructContext = {\n  value: any\n  type: string\n  branch: Array<any>\n  path: Array<string | number>\n  fail: (props?: Partial<StructFailure>) => StructFailure\n  check: (\n    value: any,\n    struct: Struct<any> | Struct<never>,\n    parent?: any,\n    key?: string | number\n  ) => IterableIterator<StructFailure>\n}\n\n/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n\nexport type StructFailure = {\n  value: StructContext['value']\n  type: StructContext['type']\n  branch: StructContext['branch']\n  path: StructContext['path']\n  [key: string]: any\n}\n\n/**\n * A `StructResult` is returned from validation functions.\n */\n\nexport type StructResult = boolean | Iterable<StructFailure>\n\n/**\n * A type utility to extract the type from a `Struct` class.\n */\n\nexport type StructType<T extends Struct<any>> = Parameters<T['refiner']>[0]\n\n/**\n * Assert that a value passes a `Struct`, throwing if it doesn't.\n */\n\nexport function assert<T>(\n  value: unknown,\n  struct: Struct<T>\n): asserts value is T {\n  const result = validate(value, struct)\n\n  if (result[0]) {\n    throw result[0]\n  }\n}\n\n/**\n * Coerce a value with the coercion logic of `Struct` and validate it.\n */\n\nexport function coerce<T>(value: unknown, struct: Struct<T>): T {\n  const ret = struct.coercer(value)\n  assert(ret, struct)\n  return ret\n}\n\n/**\n * Check if a value passes a `Struct`.\n */\n\nexport function is<T>(value: unknown, struct: Struct<T>): value is T {\n  const result = validate(value, struct)\n  return !result[0]\n}\n\n/**\n * Validate a value against a `Struct`, returning an error if invalid.\n */\n\nexport function validate<T>(\n  value: unknown,\n  struct: Struct<T>,\n  coercing: boolean = false\n): [StructError, undefined] | [undefined, T] {\n  if (coercing) {\n    value = struct.coercer(value)\n  }\n\n  const failures = check(value, struct)\n  const failure = iteratorShift(failures)\n\n  if (failure) {\n    const error = new StructError(failure, failures)\n    return [error, undefined]\n  } else {\n    return [undefined, value as T]\n  }\n}\n\n/**\n * Check a value against a `Struct`, returning an iterable of failures.\n */\n\nfunction* check<T>(\n  value: unknown,\n  struct: Struct<T>,\n  path: any[] = [],\n  branch: any[] = []\n): IterableIterator<StructFailure> {\n  const { type } = struct\n  const ctx: StructContext = {\n    value,\n    type,\n    branch,\n    path,\n    fail(props = {}) {\n      return { value, type, path, branch: [...branch, value], ...props }\n    },\n    check(v, s, parent, key) {\n      const p = parent !== undefined ? [...path, key] : path\n      const b = parent !== undefined ? [...branch, parent] : branch\n      return check(v, s, p, b)\n    },\n  }\n\n  const failures = toFailures(struct.validator(value, ctx), ctx)\n  const failure = iteratorShift(failures)\n\n  if (failure) {\n    yield failure\n    yield* failures\n  } else {\n    yield* toFailures(struct.refiner(value as T, ctx), ctx)\n  }\n}\n","import { Struct } from './struct'\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n */\n\nexport function coercion<T>(\n  struct: Struct<T>,\n  coercer: Struct<T>['coercer']\n): Struct<T> {\n  const fn = struct.coercer\n  return new Struct({\n    ...struct,\n    coercer: (value) => {\n      return fn(coercer(value))\n    },\n  })\n}\n\n/**\n * Augment a struct to coerce a default value for missing values.\n *\n * Note: You must use `coerce(value, Struct)` on the value before validating it\n * to have the value defaulted!\n */\n\nexport function defaulted<T>(\n  S: Struct<T>,\n  fallback: any,\n  strict?: true\n): Struct<T> {\n  return coercion(S, (x) => {\n    const f = typeof fallback === 'function' ? fallback() : fallback\n\n    if (x === undefined) {\n      return f\n    }\n\n    if (strict !== true && isPlainObject(x) && isPlainObject(f)) {\n      const ret = { ...x }\n      let changed = false\n\n      for (const key in f) {\n        if (ret[key] === undefined) {\n          ret[key] = f[key]\n          changed = true\n        }\n      }\n\n      if (changed) {\n        return ret\n      }\n    }\n\n    return x\n  })\n}\n\n/**\n * Coerce a value to mask its properties to only that defined in the struct.\n */\n\nexport function masked<\n  T extends { [key: string]: any },\n  V extends Record<string, Struct<any>>\n>(S: Struct<T, V>): Struct<T> {\n  return coercion(S, (x) => {\n    if (!isPlainObject(x)) {\n      return x\n    }\n\n    const ret: any = {}\n\n    for (const key in S.schema) {\n      ret[key] = x[key]\n    }\n\n    return ret\n  })\n}\n\n/**\n * Check if a value is a plain object.\n */\n\nfunction isPlainObject(value: unknown): value is { [key: string]: any } {\n  if (Object.prototype.toString.call(value) !== '[object Object]') {\n    return false\n  }\n\n  const prototype = Object.getPrototypeOf(value)\n  return prototype === null || prototype === Object.prototype\n}\n","import { Struct } from './struct'\nimport { toFailures } from './utils'\n\n/**\n * Augment a string or array struct to constrain its length to zero.\n */\n\nexport function empty<T extends string | any[]>(S: Struct<T>): Struct<T> {\n  return refinement(S, `${S.type} & Empty`, (value) => {\n    return value.length === 0\n  })\n}\n\n/**\n * Augment a string or array struct to constrain its length to being between a\n * minimum and maximum size.\n */\n\nexport function length<T extends string | any[]>(\n  S: Struct<T>,\n  min: number,\n  max: number\n): Struct<T> {\n  return refinement(S, `${S.type} & Length<${min},${max}>`, (value) => {\n    return min < value.length && value.length < max\n  })\n}\n\n/**\n * Refine a string struct to match a specific regexp pattern.\n */\n\nexport function pattern<T extends string>(\n  S: Struct<T>,\n  regexp: RegExp\n): Struct<T> {\n  return refinement(S, `${S.type} & Pattern<${regexp.source}>`, (value) => {\n    return regexp.test(value)\n  })\n}\n\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n */\n\nexport function refinement<T>(\n  struct: Struct<T>,\n  type: string,\n  refiner: Struct<T>['refiner']\n): Struct<T> {\n  const fn = struct.refiner\n  return new Struct({\n    ...struct,\n    type,\n    *refiner(value, fail) {\n      yield* toFailures(fn(value, fail), fail)\n      yield* toFailures(refiner(value, fail), fail)\n    },\n  })\n}\n","import { Struct, StructType, coerce, StructContext } from './struct'\nimport { StructRecord, StructTuple } from './utils'\n\n/**\n * Validate any value.\n */\n\nexport function any(): Struct<any> {\n  return struct('any', () => true)\n}\n\n/**\n * Validate that an array of values of a specific type.\n */\n\nexport function array(): Struct<unknown[]>\nexport function array<T>(Element: Struct<T>): Struct<T[], Struct<T>>\nexport function array<T>(Element?: Struct<T>): any {\n  return new Struct({\n    type: `Array<${Element ? Element.type : 'unknown'}>`,\n    schema: Element,\n    coercer: (value) => {\n      return Element && Array.isArray(value)\n        ? value.map((v) => coerce(v, Element))\n        : value\n    },\n    *validator(value, ctx) {\n      if (!Array.isArray(value)) {\n        yield ctx.fail()\n        return\n      }\n\n      if (Element) {\n        for (const [i, v] of value.entries()) {\n          yield* ctx.check(v, Element, value, i)\n        }\n      }\n    },\n  })\n}\n\n/**\n * Validate that boolean values.\n */\n\nexport function boolean(): Struct<boolean> {\n  return struct('boolean', (value) => {\n    return typeof value === 'boolean'\n  })\n}\n\n/**\n * Validate that `Date` values.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\n\nexport function date(): Struct<Date> {\n  return struct('Date', (value) => {\n    return value instanceof Date && !isNaN(value.getTime())\n  })\n}\n\n/**\n * Validate that a value dynamically, determing which struct to use at runtime.\n */\n\nexport function dynamic<T>(\n  fn: (value: unknown, ctx: StructContext) => Struct<T>\n): Struct<T> {\n  return struct('Dynamic<...>', (value, ctx) => {\n    return ctx.check(value, fn(value, ctx))\n  })\n}\n\n/**\n * Validate that a value against a set of potential values.\n */\n\nexport function enums<T extends number>(values: T[]): Struct<T>\nexport function enums<T extends string>(values: T[]): Struct<T>\nexport function enums<T>(values: T[]): Struct<T> {\n  return struct(`Enum<${values.map(toLiteralString)}>`, (value) => {\n    return values.includes(value as any)\n  })\n}\n\n/**\n * Validate that a value is a function.\n */\n\nexport function func(): Struct<Function> {\n  return struct('Function', (value) => {\n    return typeof value === 'function'\n  })\n}\n\n/**\n * Validate that a value is an instance of a class.\n */\n\nexport function instance<T extends { new (...args: any): any }>(\n  Class: T\n): Struct<InstanceType<T>> {\n  return struct(`InstanceOf<${Class.name}>`, (value) => {\n    return value instanceof Class\n  })\n}\n\n/**\n * Validate that a value matches all of a set of structs.\n */\n\nexport function intersection<A>(Structs: StructTuple<[A]>): Struct<A>\nexport function intersection<A, B>(Structs: StructTuple<[A, B]>): Struct<A & B>\nexport function intersection<A, B, C>(\n  Structs: StructTuple<[A, B, C]>\n): Struct<A & B & C>\nexport function intersection<A, B, C, D>(\n  Structs: StructTuple<[A, B, C, D]>\n): Struct<A & B & C & D>\nexport function intersection<A, B, C, D, E>(\n  Structs: StructTuple<[A, B, C, D, E]>\n): Struct<A & B & C & D & E>\nexport function intersection<A, B, C, D, E, F>(\n  Structs: StructTuple<[A, B, C, D, E, F]>\n): Struct<A & B & C & D & E & F>\nexport function intersection<A, B, C, D, E, F, G>(\n  Structs: StructTuple<[A, B, C, D, E, F, G]>\n): Struct<A & B & C & D & E & F & G>\nexport function intersection<A, B, C, D, E, F, G, H>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H]>\n): Struct<A & B & C & D & E & F & G & H>\nexport function intersection<A, B, C, D, E, F, G, H, I>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I]>\n): Struct<A & B & C & D & E & F & G & H & I>\nexport function intersection<A, B, C, D, E, F, G, H, I, J>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J]>\n): Struct<A & B & C & D & E & F & G & H & I & J>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L, M]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L & M>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L, M, N]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L & M & N>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L & M & N & O>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L & M & N & O & P>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L & M & N & O & P & Q>\nexport function intersection(Structs: Struct<any>[]): any {\n  return struct(Structs.map((s) => s.type).join(' & '), function* (value, ctx) {\n    for (const S of Structs) {\n      yield* ctx.check(value, S)\n    }\n  })\n}\n\n/**\n * Validate a value lazily, by constructing the struct right before the first\n * validation. This is useful for cases where you want to have self-referential\n * structs for nested data structures.\n */\n\nexport function lazy<T>(fn: () => Struct<T>): Struct<T> {\n  let S: Struct<T> | undefined\n\n  return struct('Lazy<...>', (value, ctx) => {\n    if (!S) {\n      S = fn()\n    }\n\n    return ctx.check(value, S)\n  })\n}\n\n/**\n * Validate that a value is a specific constant.\n */\n\nexport function literal<T extends boolean>(constant: T): Struct<T>\nexport function literal<T extends number>(constant: T): Struct<T>\nexport function literal<T extends string>(constant: T): Struct<T>\nexport function literal<T>(constant: T): Struct<T>\nexport function literal<T>(constant: T): Struct<T> {\n  return struct(`Literal<${toLiteralString(constant)}>`, (value) => {\n    return value === constant\n  })\n}\n\n/**\n * Validate that a value is a map with specific key and value entries.\n */\n\nexport function map<K, V>(Key: Struct<K>, Value: Struct<V>): Struct<Map<K, V>> {\n  return struct(`Map<${Key.type},${Value.type}>`, function* (value, ctx) {\n    if (!(value instanceof Map)) {\n      yield ctx.fail()\n      return\n    }\n\n    for (const [k, v] of value.entries()) {\n      yield* ctx.check(k, Key, value, k)\n      yield* ctx.check(v, Value, value, k)\n    }\n  })\n}\n\n/**\n * Validate that a value always fails.\n */\n\nexport function never(): Struct<never> {\n  return struct('never', () => false)\n}\n\n/**\n * Augment a struct to make it accept `null` values.\n */\n\nexport function nullable<T>(S: Struct<T>): Struct<T | null> {\n  return new Struct({\n    type: `${S.type} | null`,\n    schema: S.schema,\n    validator: (value, ctx) => {\n      return value === null || ctx.check(value, S)\n    },\n  })\n}\n\n/**\n * Validate that a value is a number.\n */\n\nexport function number(): Struct<number> {\n  return struct(`number`, (value) => {\n    return typeof value === 'number' && !isNaN(value)\n  })\n}\n\n/**\n * Type helper to Flatten the Union of optional and required properties.\n */\n\ntype Flatten<T> = T extends infer U ? { [K in keyof U]: U[K] } : never\n\n/**\n * Type helper to extract the optional keys of an object\n */\n\ntype OptionalKeys<T> = {\n  [K in keyof T]: undefined extends T[K] ? K : never\n}[keyof T]\n\n/**\n * Type helper to extract the required keys of an object\n */\n\ntype RequiredKeys<T> = {\n  [K in keyof T]: undefined extends T[K] ? never : K\n}[keyof T]\n\n/**\n * Type helper to create optional properties when the property value can be\n * undefined (ie. when `optional()` is used to define a type)\n */\n\ntype OptionalizeObject<T> = Flatten<\n  { [K in RequiredKeys<T>]: T[K] } & { [K in OptionalKeys<T>]?: T[K] }\n>\n\n/**\n * Validate that an object with specific entry values.\n */\n\nexport function object<V extends StructRecord<any>>(): Struct<\n  Record<string, unknown>\n>\nexport function object<V extends StructRecord<any>>(\n  Structs: V\n): Struct<OptionalizeObject<{ [K in keyof V]: StructType<V[K]> }>, V>\nexport function object<V extends StructRecord<any>>(\n  Structs?: V\n): Struct<any, any> {\n  const knowns = Structs ? Object.keys(Structs) : []\n  const Never = never()\n  return new Struct({\n    type: Structs ? `Object<{${knowns.join(',')}}>` : 'Object',\n    schema: Structs ? Structs : null,\n    coercer: Structs ? createObjectCoercer(Structs) : (x) => x,\n    *validator(value, ctx) {\n      if (typeof value !== 'object' || value == null) {\n        yield ctx.fail()\n        return\n      }\n\n      if (Structs) {\n        const unknowns = new Set(Object.keys(value))\n\n        for (const key of knowns) {\n          unknowns.delete(key)\n          const Value = Structs[key]\n          const v = value[key]\n          yield* ctx.check(v, Value, value, key)\n        }\n\n        for (const key of unknowns) {\n          const v = value[key]\n          yield* ctx.check(v, Never, value, key)\n        }\n      }\n    },\n  })\n}\n\n/**\n * Augment a struct to make it optionally accept `undefined` values.\n */\n\nexport function optional<T>(S: Struct<T>): Struct<T | undefined> {\n  return new Struct({\n    type: `${S.type}?`,\n    schema: S.schema,\n    validator: (value, ctx) => {\n      return value === undefined || ctx.check(value, S)\n    },\n  })\n}\n\n/**\n * Validate that a partial object with specific entry values.\n */\n\nexport function partial<T, V extends StructRecord<any>>(\n  Structs: V | Struct<T, V>\n): Struct<{ [K in keyof V]?: StructType<V[K]> }> {\n  if (Structs instanceof Struct) {\n    Structs = Structs.schema\n  }\n\n  const knowns = Object.keys(Structs)\n  const Never = never()\n  return new Struct({\n    type: `Partial<{${knowns.join(',')}}>`,\n    schema: Structs,\n    coercer: createObjectCoercer(Structs),\n    *validator(value, ctx) {\n      if (typeof value !== 'object' || value == null) {\n        yield ctx.fail()\n        return\n      }\n\n      const unknowns = new Set(Object.keys(value))\n\n      for (const key of knowns) {\n        unknowns.delete(key)\n\n        if (!(key in value)) {\n          continue\n        }\n\n        const Value = Structs[key]\n        const v = value[key]\n        yield* ctx.check(v, Value, value, key)\n      }\n\n      for (const key of unknowns) {\n        const v = value[key]\n        yield* ctx.check(v, Never, value, key)\n      }\n    },\n  })\n}\n\n/**\n * Validate that a value is a record with specific key and\n * value entries.\n */\n\nexport function record<K extends string | number, V>(\n  Key: Struct<K>,\n  Value: Struct<V>\n): Struct<Record<K, V>> {\n  return struct(`Record<${Key.type},${Value.type}>`, function* (value, ctx) {\n    if (typeof value !== 'object' || value == null) {\n      yield ctx.fail()\n      return\n    }\n\n    for (const k in value) {\n      const v = value[k]\n      yield* ctx.check(k, Key, value, k)\n      yield* ctx.check(v, Value, value, k)\n    }\n  })\n}\n\n/**\n * Validate that a set of values matches a specific type.\n */\n\nexport function set<T>(Element: Struct<T>): Struct<Set<T>> {\n  return struct(`Set<${Element.type}>`, (value, ctx) => {\n    if (!(value instanceof Set)) {\n      return false\n    }\n\n    for (const val of value) {\n      const [failure] = ctx.check(val, Element)\n\n      if (failure) {\n        return false\n      }\n    }\n\n    return true\n  })\n}\n\n/**\n * Validate that a value is a string.\n */\n\nexport function string(): Struct<string> {\n  return struct('string', (value) => {\n    return typeof value === 'string'\n  })\n}\n\n/**\n * Define a `Struct` instance with a type and validation function.\n */\n\nexport function struct<T>(\n  name: string,\n  validator: Struct<T>['validator']\n): Struct<T, null> {\n  return new Struct({ type: name, validator, schema: null })\n}\n\n/**\n * Validate that a value is a tuple with entries of specific types.\n */\n\nexport function tuple<A>(Structs: StructTuple<[A]>): Struct<A>\nexport function tuple<A, B>(Structs: StructTuple<[A, B]>): Struct<[A, B]>\nexport function tuple<A, B, C>(\n  Structs: StructTuple<[A, B, C]>\n): Struct<[A, B, C]>\nexport function tuple<A, B, C, D>(\n  Structs: StructTuple<[A, B, C, D]>\n): Struct<[A, B, C, D]>\nexport function tuple<A, B, C, D, E>(\n  Structs: StructTuple<[A, B, C, D, E]>\n): Struct<[A, B, C, D, E]>\nexport function tuple<A, B, C, D, E, F>(\n  Structs: StructTuple<[A, B, C, D, E, F]>\n): Struct<[A, B, C, D, E, F]>\nexport function tuple<A, B, C, D, E, F, G>(\n  Structs: StructTuple<[A, B, C, D, E, F, G]>\n): Struct<[A, B, C, D, E, F, G]>\nexport function tuple<A, B, C, D, E, F, G, H>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H]>\n): Struct<[A, B, C, D, E, F, G, H]>\nexport function tuple<A, B, C, D, E, F, G, H, I>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I]>\n): Struct<[A, B, C, D, E, F, G, H, I]>\nexport function tuple<A, B, C, D, E, F, G, H, I, J>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J]>\n): Struct<[A, B, C, D, E, F, G, H, I, J]>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K]>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L]>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L, M]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M]>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L, M, N]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M, N]>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]>\nexport function tuple(Elements: Struct<any>[]): any {\n  const Never = never()\n\n  return struct(`[${Elements.map((s) => s.type).join(',')}]`, function* (\n    value,\n    ctx\n  ) {\n    if (!Array.isArray(value)) {\n      yield ctx.fail()\n      return\n    }\n\n    for (const [index, Element] of Elements.entries()) {\n      const v = value[index]\n      yield* ctx.check(v, Element, value, index)\n    }\n\n    if (value.length > Elements.length) {\n      const index = Elements.length\n      const v = value[index]\n      yield* ctx.check(v, Never, value, index)\n    }\n  })\n}\n\n/**\n * Validate that a value matches a specific strutural interface, like the\n * structural typing that TypeScript uses.\n */\n\nexport function type<V extends StructRecord<any>>(\n  Structs: V\n): Struct<{ [K in keyof V]: StructType<V[K]> }> {\n  const keys = Object.keys(Structs)\n\n  return struct(`Type<{${keys.join(',')}}>`, function* (value, ctx) {\n    if (typeof value !== 'object' || value == null) {\n      yield ctx.fail()\n      return\n    }\n\n    for (const key of keys) {\n      const Value = Structs[key]\n      const v = (value as any)[key]\n      yield* ctx.check(v, Value, value, key)\n    }\n  })\n}\n\n/**\n * Validate that a value is one of a set of types.\n */\n\nexport function union<A>(Structs: StructTuple<[A]>): Struct<A>\nexport function union<A, B>(Structs: StructTuple<[A, B]>): Struct<A | B>\nexport function union<A, B, C>(\n  Structs: StructTuple<[A, B, C]>\n): Struct<A | B | C>\nexport function union<A, B, C, D>(\n  Structs: StructTuple<[A, B, C, D]>\n): Struct<A | B | C | D>\nexport function union<A, B, C, D, E>(\n  Structs: StructTuple<[A, B, C, D, E]>\n): Struct<A | B | C | D | E>\nexport function union<A, B, C, D, E, F>(\n  Structs: StructTuple<[A, B, C, D, E, F]>\n): Struct<A | B | C | D | E | F>\nexport function union<A, B, C, D, E, F, G>(\n  Structs: StructTuple<[A, B, C, D, E, F, G]>\n): Struct<A | B | C | D | E | F | G>\nexport function union<A, B, C, D, E, F, G, H>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H]>\n): Struct<A | B | C | D | E | F | G | H>\nexport function union<A, B, C, D, E, F, G, H, I>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I]>\n): Struct<A | B | C | D | E | F | G | H | I>\nexport function union<A, B, C, D, E, F, G, H, I, J>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J]>\n): Struct<A | B | C | D | E | F | G | H | I | J>\nexport function union<A, B, C, D, E, F, G, H, I, J, K>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L, M]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L | M>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L, M, N]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L | M | N>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L | M | N | O>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(\n  Structs: StructTuple<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q>\nexport function union(Structs: Struct<any>[]): any {\n  return struct(`${Structs.map((s) => s.type).join(' | ')}`, function* (\n    value,\n    ctx\n  ) {\n    for (const S of Structs) {\n      const [...failures] = ctx.check(value, S)\n\n      if (failures.length === 0) {\n        return\n      }\n    }\n\n    yield ctx.fail()\n  })\n}\n\n/**\n * Convert a value to a literal string.\n */\n\nfunction toLiteralString(value: any): string {\n  return typeof value === 'string'\n    ? `\"${value.replace(/\"/g, '\"')}\"`\n    : `${value}`\n}\n\n/**\n * Coerce the values of an object-like struct.\n */\n\nfunction createObjectCoercer<V extends StructRecord<any>>(\n  Structs: V\n): (value: unknown) => unknown {\n  const knowns = Object.keys(Structs)\n\n  return (value) => {\n    if (typeof value !== 'object' || value == null) {\n      return value\n    }\n\n    const ret = {}\n    const unknowns = new Set(Object.keys(value))\n\n    for (const key of knowns) {\n      unknowns.delete(key)\n      const Value = Structs[key]\n      const v = value[key]\n      ret[key] = coerce(v, Value)\n    }\n\n    for (const key of unknowns) {\n      ret[key] = value[key]\n    }\n\n    return ret\n  }\n}\n"],"names":["toFailures","result","context","fail","iteratorShift","input","done","value","next","undefined","Struct","constructor","props","type","schema","coercer","validator","refiner","StructError","TypeError","failure","moreFailures","path","branch","rest","message","length","join","JSON","stringify","failuresResult","failures","Object","assign","stack","Error","__proto__","prototype","assert","struct","validate","coerce","ret","is","coercing","check","error","ctx","v","s","parent","key","p","b","coercion","fn","defaulted","S","fallback","strict","x","f","isPlainObject","changed","masked","toString","call","getPrototypeOf","empty","refinement","min","max","pattern","regexp","source","test","any","array","Element","Array","isArray","map","i","entries","boolean","date","Date","isNaN","getTime","dynamic","enums","values","toLiteralString","includes","func","instance","Class","name","intersection","Structs","lazy","literal","constant","Key","Value","Map","k","never","nullable","number","object","knowns","keys","Never","createObjectCoercer","unknowns","Set","delete","optional","partial","record","set","val","string","tuple","Elements","index","union","replace"],"mappings":"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"}