{"version":3,"sources":["../../src/abi.ts"],"names":["getIdentifier","pack","unpack","concat","encode","input","values","types","map","type","Buffer","alloc","encodeWithIdentifier","contractFunction","identifier","from","encoded","inputs","decode","buffer"],"mappings":"AACA,SAASA,aAAT,QAA8B,cAA9B;AACA,SAASC,IAAT,EAAeC,MAAf,QAA6B,iBAA7B;AACA,SAASC,MAAT,QAAuB,gBAAvB;AASA,OAAO,MAAMC,MAAM,GAAG,CAACC,KAAD,EAAuCC,MAAvC,KAAyE;AAC7F,QAAMC,KAAK,GAAGF,KAAK,CAACG,GAAN,CAAWC,IAAD,IAAU;AAChC,QAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC5B,aAAOA,IAAP;AACD;;AAED,WAAOA,IAAI,CAACA,IAAZ;AACD,GANa,CAAd;AAQA,SAAOR,IAAI,CAACS,MAAM,CAACC,KAAP,CAAa,CAAb,CAAD,EAAkBL,MAAlB,EAA0BC,KAA1B,CAAX;AACD,CAVM;AAmBP,OAAO,MAAMK,oBAAoB,GAAG,CAACC,gBAAD,EAAqCP,MAArC,KAAuE;AACzG,QAAMQ,UAAU,GAAGJ,MAAM,CAACK,IAAP,CAAYf,aAAa,CAACa,gBAAD,CAAzB,EAA6C,KAA7C,CAAnB;AACA,QAAMG,OAAO,GAAGZ,MAAM,CAACS,gBAAgB,CAACI,MAAlB,EAA0BX,MAA1B,CAAtB;AAEA,SAAOH,MAAM,CAACW,UAAD,EAAaE,OAAb,CAAb;AACD,CALM;AAOP,OAAO,MAAME,MAAM,GAAG,CAAsBb,KAAtB,EAA4Dc,MAA5D,KAAkF;AACtG,QAAMZ,KAAK,GAAGF,KAAK,CAACG,GAAN,CAAWC,IAAD,IAAU;AAChC,QAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC5B,aAAOA,IAAP;AACD;;AAED,WAAOA,IAAI,CAACA,IAAZ;AACD,GANa,CAAd;AAQA,SAAOP,MAAM,CAACiB,MAAD,EAASZ,KAAT,CAAb;AACD,CAVM","sourcesContent":["import { ContractFunction, ContractInput } from './contract';\nimport { getIdentifier } from './identifier';\nimport { pack, unpack } from './parsers/array';\nimport { concat } from './utils/buffer';\n\n/**\n * Encode the input data with the provided types.\n *\n * @param {(ContractInput | string)[]} input\n * @param {unknown[]} values\n * @return {Buffer}\n */\nexport const encode = (input: Array<ContractInput | string>, values: unknown[]): Uint8Array => {\n  const types = input.map((type) => {\n    if (typeof type === 'string') {\n      return type;\n    }\n\n    return type.type;\n  });\n\n  return pack(Buffer.alloc(0), values, types);\n};\n\n/**\n * Encode the input data with the provided types, and prepend the function identifier.\n *\n * @param {ContractFunction} contractFunction\n * @param {unknown[]} values\n * @return {Buffer}\n */\nexport const encodeWithIdentifier = (contractFunction: ContractFunction, values: unknown[]): Uint8Array => {\n  const identifier = Buffer.from(getIdentifier(contractFunction), 'hex');\n  const encoded = encode(contractFunction.inputs, values);\n\n  return concat(identifier, encoded);\n};\n\nexport const decode = <T extends unknown[]>(input: Array<ContractInput | string>, buffer: Buffer): T => {\n  const types = input.map((type) => {\n    if (typeof type === 'string') {\n      return type;\n    }\n\n    return type.type;\n  });\n\n  return unpack(buffer, types) as T;\n};\n"],"file":"abi.js"}