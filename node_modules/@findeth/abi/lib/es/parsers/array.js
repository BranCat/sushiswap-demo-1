import { concat, concatMultiple, toBuffer, toNumber } from '../utils/buffer';
import { decodeAddress, encodeAddress } from './address';
import { decodeBytes, encodeBytes } from './bytes';
import { decodeFixedBytes, encodeFixedBytes, isFixedBytes } from './fixed-bytes';
import { decodeNumber, encodeNumber, isNumber } from './number';
import { decodeString, encodeString } from './string';
const ARRAY_REGEX = /^(.*)\[]$/;
export const isArray = type => {
  return ARRAY_REGEX.test(type);
};
export const getType = type => {
  return type.match(ARRAY_REGEX)[1];
};
export const encodeArray = (buffer, values, type) => {
  if (!isArray(type)) {
    throw new Error('Invalid type: type is not array');
  }

  const actualType = getType(type);
  const length = toBuffer(values.length);
  const arrayBuffer = concat(buffer, length);
  return pack(arrayBuffer, values, new Array(values.length).fill(actualType));
};
export const decodeArray = (value, buffer, type) => {
  if (!isArray(type)) {
    throw new Error('Invalid type: type is not array');
  }

  const actualType = getType(type);
  const pointer = Number(toNumber(value));
  const length = Number(toNumber(buffer.subarray(pointer, pointer + 32)));
  const arrayPointer = pointer + 32;
  const arrayBuffer = buffer.subarray(arrayPointer);
  return unpack(arrayBuffer, new Array(length).fill(actualType));
};
const parsers = {
  address: {
    encode: encodeAddress,
    decode: decodeAddress
  },
  array: {
    dynamic: true,
    encode: encodeArray,
    decode: decodeArray
  },
  bytes: {
    dynamic: true,
    encode: encodeBytes,
    decode: decodeBytes
  },
  fixedBytes: {
    encode: encodeFixedBytes,
    decode: decodeFixedBytes
  },
  number: {
    encode: encodeNumber,
    decode: decodeNumber
  },
  string: {
    dynamic: true,
    encode: encodeString,
    decode: decodeString
  }
};
export const getParser = type => {
  if (parsers[type]) {
    return parsers[type];
  }

  if (isFixedBytes(type)) {
    return parsers.fixedBytes;
  }

  if (isNumber(type) || type === 'bool') {
    return parsers.number;
  }

  if (isArray(type)) {
    return parsers.array;
  }

  throw new Error(`type "${type}" is not supported`);
};
export const pack = (buffer, values, types) => {
  const {
    staticBuffer: packedStaticBuffer,
    dynamicBuffer: packedDynamicBuffer,
    updateFunctions: packedUpdateFunctions
  } = types.reduce(({
    staticBuffer,
    dynamicBuffer,
    updateFunctions
  }, type, index) => {
    const parser = getParser(type);
    const value = values[index];

    if (parser.dynamic) {
      const offset = dynamicBuffer.length;
      const staticOffset = staticBuffer.length;
      const newStaticBuffer = concat(staticBuffer, Buffer.alloc(32, 0));
      const newDynamicBuffer = parser.encode(dynamicBuffer, value, type);

      const update = oldBuffer => {
        return concatMultiple([oldBuffer.subarray(0, staticOffset), toBuffer(oldBuffer.length + offset), oldBuffer.subarray(staticOffset + 32)]);
      };

      return {
        staticBuffer: newStaticBuffer,
        dynamicBuffer: newDynamicBuffer,
        updateFunctions: [...updateFunctions, update]
      };
    }

    const newBuffer = parser.encode(staticBuffer, value, type);
    return {
      staticBuffer: newBuffer,
      dynamicBuffer,
      updateFunctions
    };
  }, {
    staticBuffer: new Uint8Array(0),
    dynamicBuffer: new Uint8Array(0),
    updateFunctions: []
  });
  const updatedStaticBuffer = packedUpdateFunctions.reduce((target, update) => update(target), packedStaticBuffer);
  return concatMultiple([buffer, updatedStaticBuffer, packedDynamicBuffer]);
};
export function* iterate(buffer, chunkSize) {
  for (let i = 0; i < buffer.length; i += chunkSize) {
    yield buffer.slice(i, i + chunkSize);
  }

  return buffer;
}
export const unpack = (buffer, types) => {
  const iterator = iterate(buffer, 32);
  return types.map(type => {
    const {
      value,
      done
    } = iterator.next();

    if (done) {
      throw new Error('input data has an invalid length');
    }

    const parser = getParser(type);
    return parser.decode(value, buffer, type);
  });
};
//# sourceMappingURL=array.js.map