import { concat, toBuffer, toNumber } from '../utils/buffer';
import { fromTwosComplement, toTwosComplement } from '../utils/twos-complement';
const NUMBER_REGEX = /^u?int([0-9]*)?$/;

const isSigned = type => {
  return type.startsWith('i');
};

export const isNumber = type => {
  return NUMBER_REGEX.test(type);
};
export const getBitLength = type => {
  var _type$match$, _type$match;

  const rawBits = (_type$match$ = (_type$match = type.match(NUMBER_REGEX)) === null || _type$match === void 0 ? void 0 : _type$match[1]) !== null && _type$match$ !== void 0 ? _type$match$ : '256';
  return Number(rawBits);
};
export const inRange = (value, type) => {
  const bits = BigInt(getBitLength(type));

  if (isSigned(type)) {
    const maxSignedValue = 2n ** (bits - 1n) - 1n;
    return value >= -maxSignedValue - 1n && value <= maxSignedValue;
  }

  const maxValue = 2n ** bits - 1n;
  return value >= 0n && value <= maxValue;
};

const asNumber = value => {
  if (typeof value === 'bigint') {
    return value;
  }

  return BigInt(value);
};

export const encodeNumber = (buffer, value, type) => {
  const numberValue = asNumber(value);

  if (!inRange(numberValue, type)) {
    throw new Error(`Cannot encode number: value is out of range for type ${type}`);
  }

  if (isSigned(type)) {
    return concat(buffer, toTwosComplement(numberValue, 32));
  }

  return concat(buffer, toBuffer(numberValue));
};
export const decodeNumber = (value, _, type) => {
  if (isSigned(type)) {
    return fromTwosComplement(value);
  }

  return toNumber(value);
};
//# sourceMappingURL=number.js.map