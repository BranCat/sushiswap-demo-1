{"version":3,"sources":["../../../src/parsers/array.ts"],"names":["concat","concatMultiple","toBuffer","toNumber","decodeAddress","encodeAddress","decodeBytes","encodeBytes","decodeFixedBytes","encodeFixedBytes","isFixedBytes","decodeNumber","encodeNumber","isNumber","decodeString","encodeString","ARRAY_REGEX","isArray","type","test","getType","match","encodeArray","buffer","values","Error","actualType","length","arrayBuffer","pack","Array","fill","decodeArray","value","pointer","Number","subarray","arrayPointer","unpack","parsers","address","encode","decode","array","dynamic","bytes","fixedBytes","number","string","getParser","types","staticBuffer","packedStaticBuffer","dynamicBuffer","packedDynamicBuffer","updateFunctions","packedUpdateFunctions","reduce","index","parser","offset","staticOffset","newStaticBuffer","Buffer","alloc","newDynamicBuffer","update","oldBuffer","newBuffer","Uint8Array","updatedStaticBuffer","target","iterate","chunkSize","i","slice","iterator","map","done","next"],"mappings":"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","sourcesContent":["import { concat, concatMultiple, toBuffer, toNumber } from '../utils/buffer';\nimport { decodeAddress, encodeAddress } from './address';\nimport { decodeBytes, encodeBytes } from './bytes';\nimport { decodeFixedBytes, encodeFixedBytes, isFixedBytes } from './fixed-bytes';\nimport { decodeNumber, encodeNumber, isNumber } from './number';\nimport { DecodeFunction, EncodeFunction, Parser } from './parser';\nimport { decodeString, encodeString } from './string';\n\nconst ARRAY_REGEX = /^(.*)\\[]$/;\n\n/**\n * Check if a type is an array type.\n *\n * @param {string} type\n * @return {boolean}\n */\nexport const isArray = (type: string): boolean => {\n  return ARRAY_REGEX.test(type);\n};\n\n/**\n * Get the \"inner\" type for an array type. E.g. `getType(\"uint256[]\")` -> uint256.\n *\n * @param {string} type\n * @return {string}\n */\nexport const getType = (type: string): string => {\n  return type.match(ARRAY_REGEX)![1];\n};\n\nexport const encodeArray: EncodeFunction = (buffer: Uint8Array, values: unknown[], type: string): Uint8Array => {\n  if (!isArray(type)) {\n    throw new Error('Invalid type: type is not array');\n  }\n\n  const actualType = getType(type);\n  const length = toBuffer(values.length);\n\n  const arrayBuffer = concat(buffer, length);\n\n  return pack(arrayBuffer, values, new Array(values.length).fill(actualType));\n};\n\nexport const decodeArray: DecodeFunction = (value: Uint8Array, buffer: Uint8Array, type: string): unknown[] => {\n  if (!isArray(type)) {\n    throw new Error('Invalid type: type is not array');\n  }\n\n  const actualType = getType(type);\n  const pointer = Number(toNumber(value));\n  const length = Number(toNumber(buffer.subarray(pointer, pointer + 32)));\n\n  const arrayPointer = pointer + 32;\n  const arrayBuffer = buffer.subarray(arrayPointer);\n\n  return unpack(arrayBuffer, new Array(length).fill(actualType));\n};\n\n/**\n * All available parsers.\n */\nconst parsers: Record<string, Parser> = {\n  address: {\n    encode: encodeAddress,\n    decode: decodeAddress\n  },\n  array: {\n    dynamic: true,\n    encode: encodeArray,\n    decode: decodeArray\n  },\n  bytes: {\n    dynamic: true,\n    encode: encodeBytes,\n    decode: decodeBytes\n  },\n  fixedBytes: {\n    encode: encodeFixedBytes,\n    decode: decodeFixedBytes\n  },\n  number: {\n    encode: encodeNumber,\n    decode: decodeNumber\n  },\n  string: {\n    dynamic: true,\n    encode: encodeString,\n    decode: decodeString\n  }\n};\n\n/**\n * Get a parser for a type. Throws an error if the parser could not be found.\n *\n * @param {string} type\n * @return {Parser}\n */\nexport const getParser = (type: string): Parser => {\n  if (parsers[type]) {\n    return parsers[type];\n  }\n\n  // bytes[n]\n  if (isFixedBytes(type)) {\n    return parsers.fixedBytes;\n  }\n\n  // u?int[n], bool\n  if (isNumber(type) || type === 'bool') {\n    return parsers.number;\n  }\n\n  // type[]\n  if (isArray(type)) {\n    return parsers.array;\n  }\n\n  throw new Error(`type \"${type}\" is not supported`);\n};\n\ninterface PackState {\n  staticBuffer: Uint8Array;\n  dynamicBuffer: Uint8Array;\n  updateFunctions: Array<(buffer: Uint8Array) => Uint8Array>;\n}\n\n/**\n * Pack multiple values into a single Buffer, based on the provided types. Returns a new buffer with the\n * packed values.\n *\n * Based on the implementation of Ethers.js:\n * https://github.com/ethers-io/ethers.js/blob/fa87417e9416d99a37d9a2668a1e54feb7e342fc/packages/abi/src.ts/coders/array.ts\n *\n * @param {Buffer} buffer\n * @param {any[]} values\n * @param {string[]} types\n * @return {Buffer}\n */\nexport const pack = (buffer: Uint8Array, values: unknown[], types: string[]): Uint8Array => {\n  const {\n    staticBuffer: packedStaticBuffer,\n    dynamicBuffer: packedDynamicBuffer,\n    updateFunctions: packedUpdateFunctions\n  } = types.reduce<PackState>(\n    ({ staticBuffer, dynamicBuffer, updateFunctions }, type, index) => {\n      const parser = getParser(type);\n      const value = values[index];\n\n      if (parser.dynamic) {\n        const offset = dynamicBuffer.length;\n        const staticOffset = staticBuffer.length;\n\n        const newStaticBuffer = concat(staticBuffer, Buffer.alloc(32, 0));\n        const newDynamicBuffer = parser.encode(dynamicBuffer, value, type);\n\n        const update = (oldBuffer: Uint8Array): Uint8Array => {\n          return concatMultiple([\n            oldBuffer.subarray(0, staticOffset),\n            toBuffer(oldBuffer.length + offset),\n            oldBuffer.subarray(staticOffset + 32)\n          ]);\n        };\n\n        return {\n          staticBuffer: newStaticBuffer,\n          dynamicBuffer: newDynamicBuffer,\n          updateFunctions: [...updateFunctions, update]\n        };\n      }\n\n      const newBuffer = parser.encode(staticBuffer, value, type);\n\n      return { staticBuffer: newBuffer, dynamicBuffer, updateFunctions };\n    },\n    { staticBuffer: new Uint8Array(0), dynamicBuffer: new Uint8Array(0), updateFunctions: [] }\n  );\n\n  const updatedStaticBuffer = packedUpdateFunctions.reduce<Uint8Array>(\n    (target, update) => update(target),\n    packedStaticBuffer\n  );\n\n  return concatMultiple([buffer, updatedStaticBuffer, packedDynamicBuffer]);\n};\n\n/**\n * Iterate over a `Buffer` with provided `chunkSize`.\n *\n * @param {Buffer} buffer\n * @param {number} chunkSize\n * @return {Generator<Buffer, Buffer, void>}\n */\nexport function* iterate(buffer: Uint8Array, chunkSize: number): Generator<Uint8Array, Uint8Array, void> {\n  for (let i = 0; i < buffer.length; i += chunkSize) {\n    yield buffer.slice(i, i + chunkSize);\n  }\n\n  return buffer;\n}\n\nexport const unpack = (buffer: Uint8Array, types: string[]): unknown[] => {\n  const iterator = iterate(buffer, 32);\n\n  return types.map((type) => {\n    const { value, done } = iterator.next();\n    if (done) {\n      throw new Error('input data has an invalid length');\n    }\n\n    const parser = getParser(type);\n    return parser.decode(value, buffer, type);\n  });\n};\n"],"file":"array.js"}