{"version":3,"sources":["../../../src/parsers/number.ts"],"names":["concat","toBuffer","toNumber","fromTwosComplement","toTwosComplement","NUMBER_REGEX","isSigned","type","startsWith","isNumber","test","getBitLength","rawBits","match","Number","inRange","value","bits","BigInt","maxSignedValue","maxValue","asNumber","encodeNumber","buffer","numberValue","Error","decodeNumber","_"],"mappings":"AAAA,SAASA,MAAT,EAAiBC,QAAjB,EAA2BC,QAA3B,QAA2C,iBAA3C;AACA,SAASC,kBAAT,EAA6BC,gBAA7B,QAAqD,0BAArD;AAGA,MAAMC,YAAY,GAAG,kBAArB;;AAEA,MAAMC,QAAQ,GAAIC,IAAD,IAA2B;AAC1C,SAAOA,IAAI,CAACC,UAAL,CAAgB,GAAhB,CAAP;AACD,CAFD;;AAIA,OAAO,MAAMC,QAAQ,GAAIF,IAAD,IAA2B;AACjD,SAAOF,YAAY,CAACK,IAAb,CAAkBH,IAAlB,CAAP;AACD,CAFM;AAIP,OAAO,MAAMI,YAAY,GAAIJ,IAAD,IAA0B;AAAA;;AACpD,QAAMK,OAAO,kCAAGL,IAAI,CAACM,KAAL,CAAWR,YAAX,CAAH,gDAAG,YAA2B,CAA3B,CAAH,uDAAoC,KAAjD;AACA,SAAOS,MAAM,CAACF,OAAD,CAAb;AACD,CAHM;AAKP,OAAO,MAAMG,OAAO,GAAG,CAACC,KAAD,EAAgBT,IAAhB,KAA0C;AAC/D,QAAMU,IAAI,GAAGC,MAAM,CAACP,YAAY,CAACJ,IAAD,CAAb,CAAnB;;AAEA,MAAID,QAAQ,CAACC,IAAD,CAAZ,EAAoB;AAClB,UAAMY,cAAc,GAAG,OAAOF,IAAI,GAAG,EAAd,IAAoB,EAA3C;AACA,WAAOD,KAAK,IAAI,CAACG,cAAD,GAAkB,EAA3B,IAAiCH,KAAK,IAAIG,cAAjD;AACD;;AAED,QAAMC,QAAQ,GAAG,MAAMH,IAAN,GAAa,EAA9B;AACA,SAAOD,KAAK,IAAI,EAAT,IAAeA,KAAK,IAAII,QAA/B;AACD,CAVM;;AAYP,MAAMC,QAAQ,GAAIL,KAAD,IAAoC;AACnD,MAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7B,WAAOA,KAAP;AACD;;AAED,SAAOE,MAAM,CAACF,KAAD,CAAb;AACD,CAND;;AAQA,OAAO,MAAMM,YAA4B,GAAG,CAACC,MAAD,EAAqBP,KAArB,EAA6CT,IAA7C,KAA0E;AACpH,QAAMiB,WAAW,GAAGH,QAAQ,CAACL,KAAD,CAA5B;;AAEA,MAAI,CAACD,OAAO,CAACS,WAAD,EAAcjB,IAAd,CAAZ,EAAiC;AAC/B,UAAM,IAAIkB,KAAJ,CAAW,wDAAuDlB,IAAK,EAAvE,CAAN;AACD;;AAED,MAAID,QAAQ,CAACC,IAAD,CAAZ,EAAoB;AAClB,WAAOP,MAAM,CAACuB,MAAD,EAASnB,gBAAgB,CAACoB,WAAD,EAAc,EAAd,CAAzB,CAAb;AACD;;AAED,SAAOxB,MAAM,CAACuB,MAAD,EAAStB,QAAQ,CAACuB,WAAD,CAAjB,CAAb;AACD,CAZM;AAcP,OAAO,MAAME,YAA4B,GAAG,CAACV,KAAD,EAAoBW,CAApB,EAAuBpB,IAAvB,KAAgD;AAC1F,MAAID,QAAQ,CAACC,IAAD,CAAZ,EAAoB;AAClB,WAAOJ,kBAAkB,CAACa,KAAD,CAAzB;AACD;;AAED,SAAOd,QAAQ,CAACc,KAAD,CAAf;AACD,CANM","sourcesContent":["import { concat, toBuffer, toNumber } from '../utils/buffer';\nimport { fromTwosComplement, toTwosComplement } from '../utils/twos-complement';\nimport { DecodeFunction, EncodeFunction } from './parser';\n\nconst NUMBER_REGEX = /^u?int([0-9]*)?$/;\n\nconst isSigned = (type: string): boolean => {\n  return type.startsWith('i');\n};\n\nexport const isNumber = (type: string): boolean => {\n  return NUMBER_REGEX.test(type);\n};\n\nexport const getBitLength = (type: string): number => {\n  const rawBits = type.match(NUMBER_REGEX)?.[1] ?? '256';\n  return Number(rawBits);\n};\n\nexport const inRange = (value: bigint, type: string): boolean => {\n  const bits = BigInt(getBitLength(type));\n\n  if (isSigned(type)) {\n    const maxSignedValue = 2n ** (bits - 1n) - 1n;\n    return value >= -maxSignedValue - 1n && value <= maxSignedValue;\n  }\n\n  const maxValue = 2n ** bits - 1n;\n  return value >= 0n && value <= maxValue;\n};\n\nconst asNumber = (value: string | bigint): bigint => {\n  if (typeof value === 'bigint') {\n    return value;\n  }\n\n  return BigInt(value);\n};\n\nexport const encodeNumber: EncodeFunction = (buffer: Uint8Array, value: string | bigint, type: string): Uint8Array => {\n  const numberValue = asNumber(value);\n\n  if (!inRange(numberValue, type)) {\n    throw new Error(`Cannot encode number: value is out of range for type ${type}`);\n  }\n\n  if (isSigned(type)) {\n    return concat(buffer, toTwosComplement(numberValue, 32));\n  }\n\n  return concat(buffer, toBuffer(numberValue));\n};\n\nexport const decodeNumber: DecodeFunction = (value: Uint8Array, _, type: string): bigint => {\n  if (isSigned(type)) {\n    return fromTwosComplement(value);\n  }\n\n  return toNumber(value);\n};\n"],"file":"number.js"}