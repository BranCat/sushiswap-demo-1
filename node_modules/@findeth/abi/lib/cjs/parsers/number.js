"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decodeNumber = exports.encodeNumber = exports.inRange = exports.getBitLength = exports.isNumber = void 0;

var _buffer = require("../utils/buffer");

var _twosComplement = require("../utils/twos-complement");

const NUMBER_REGEX = /^u?int([0-9]*)?$/;

const isSigned = type => {
  return type.startsWith('i');
};

const isNumber = type => {
  return NUMBER_REGEX.test(type);
};

exports.isNumber = isNumber;

const getBitLength = type => {
  var _type$match$, _type$match;

  const rawBits = (_type$match$ = (_type$match = type.match(NUMBER_REGEX)) === null || _type$match === void 0 ? void 0 : _type$match[1]) !== null && _type$match$ !== void 0 ? _type$match$ : '256';
  return Number(rawBits);
};

exports.getBitLength = getBitLength;

const inRange = (value, type) => {
  const bits = BigInt(getBitLength(type));

  if (isSigned(type)) {
    const maxSignedValue = 2n ** (bits - 1n) - 1n;
    return value >= -maxSignedValue - 1n && value <= maxSignedValue;
  }

  const maxValue = 2n ** bits - 1n;
  return value >= 0n && value <= maxValue;
};

exports.inRange = inRange;

const asNumber = value => {
  if (typeof value === 'bigint') {
    return value;
  }

  return BigInt(value);
};

const encodeNumber = (buffer, value, type) => {
  const numberValue = asNumber(value);

  if (!inRange(numberValue, type)) {
    throw new Error(`Cannot encode number: value is out of range for type ${type}`);
  }

  if (isSigned(type)) {
    return (0, _buffer.concat)(buffer, (0, _twosComplement.toTwosComplement)(numberValue, 32));
  }

  return (0, _buffer.concat)(buffer, (0, _buffer.toBuffer)(numberValue));
};

exports.encodeNumber = encodeNumber;

const decodeNumber = (value, _, type) => {
  if (isSigned(type)) {
    return (0, _twosComplement.fromTwosComplement)(value);
  }

  return (0, _buffer.toNumber)(value);
};

exports.decodeNumber = decodeNumber;
//# sourceMappingURL=number.js.map