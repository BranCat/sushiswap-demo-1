"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.iterate = iterate;
exports.unpack = exports.pack = exports.getParser = exports.decodeArray = exports.encodeArray = exports.getType = exports.isArray = void 0;

var _buffer = require("../utils/buffer");

var _address = require("./address");

var _bytes = require("./bytes");

var _fixedBytes = require("./fixed-bytes");

var _number = require("./number");

var _string = require("./string");

const ARRAY_REGEX = /^(.*)\[]$/;

const isArray = type => {
  return ARRAY_REGEX.test(type);
};

exports.isArray = isArray;

const getType = type => {
  return type.match(ARRAY_REGEX)[1];
};

exports.getType = getType;

const encodeArray = (buffer, values, type) => {
  if (!isArray(type)) {
    throw new Error('Invalid type: type is not array');
  }

  const actualType = getType(type);
  const length = (0, _buffer.toBuffer)(values.length);
  const arrayBuffer = (0, _buffer.concat)(buffer, length);
  return pack(arrayBuffer, values, new Array(values.length).fill(actualType));
};

exports.encodeArray = encodeArray;

const decodeArray = (value, buffer, type) => {
  if (!isArray(type)) {
    throw new Error('Invalid type: type is not array');
  }

  const actualType = getType(type);
  const pointer = Number((0, _buffer.toNumber)(value));
  const length = Number((0, _buffer.toNumber)(buffer.subarray(pointer, pointer + 32)));
  const arrayPointer = pointer + 32;
  const arrayBuffer = buffer.subarray(arrayPointer);
  return unpack(arrayBuffer, new Array(length).fill(actualType));
};

exports.decodeArray = decodeArray;
const parsers = {
  address: {
    encode: _address.encodeAddress,
    decode: _address.decodeAddress
  },
  array: {
    dynamic: true,
    encode: encodeArray,
    decode: decodeArray
  },
  bytes: {
    dynamic: true,
    encode: _bytes.encodeBytes,
    decode: _bytes.decodeBytes
  },
  fixedBytes: {
    encode: _fixedBytes.encodeFixedBytes,
    decode: _fixedBytes.decodeFixedBytes
  },
  number: {
    encode: _number.encodeNumber,
    decode: _number.decodeNumber
  },
  string: {
    dynamic: true,
    encode: _string.encodeString,
    decode: _string.decodeString
  }
};

const getParser = type => {
  if (parsers[type]) {
    return parsers[type];
  }

  if ((0, _fixedBytes.isFixedBytes)(type)) {
    return parsers.fixedBytes;
  }

  if ((0, _number.isNumber)(type) || type === 'bool') {
    return parsers.number;
  }

  if (isArray(type)) {
    return parsers.array;
  }

  throw new Error(`type "${type}" is not supported`);
};

exports.getParser = getParser;

const pack = (buffer, values, types) => {
  const {
    staticBuffer: packedStaticBuffer,
    dynamicBuffer: packedDynamicBuffer,
    updateFunctions: packedUpdateFunctions
  } = types.reduce(({
    staticBuffer,
    dynamicBuffer,
    updateFunctions
  }, type, index) => {
    const parser = getParser(type);
    const value = values[index];

    if (parser.dynamic) {
      const offset = dynamicBuffer.length;
      const staticOffset = staticBuffer.length;
      const newStaticBuffer = (0, _buffer.concat)(staticBuffer, Buffer.alloc(32, 0));
      const newDynamicBuffer = parser.encode(dynamicBuffer, value, type);

      const update = oldBuffer => {
        return (0, _buffer.concatMultiple)([oldBuffer.subarray(0, staticOffset), (0, _buffer.toBuffer)(oldBuffer.length + offset), oldBuffer.subarray(staticOffset + 32)]);
      };

      return {
        staticBuffer: newStaticBuffer,
        dynamicBuffer: newDynamicBuffer,
        updateFunctions: [...updateFunctions, update]
      };
    }

    const newBuffer = parser.encode(staticBuffer, value, type);
    return {
      staticBuffer: newBuffer,
      dynamicBuffer,
      updateFunctions
    };
  }, {
    staticBuffer: new Uint8Array(0),
    dynamicBuffer: new Uint8Array(0),
    updateFunctions: []
  });
  const updatedStaticBuffer = packedUpdateFunctions.reduce((target, update) => update(target), packedStaticBuffer);
  return (0, _buffer.concatMultiple)([buffer, updatedStaticBuffer, packedDynamicBuffer]);
};

exports.pack = pack;

function* iterate(buffer, chunkSize) {
  for (let i = 0; i < buffer.length; i += chunkSize) {
    yield buffer.slice(i, i + chunkSize);
  }

  return buffer;
}

const unpack = (buffer, types) => {
  const iterator = iterate(buffer, 32);
  return types.map(type => {
    const {
      value,
      done
    } = iterator.next();

    if (done) {
      throw new Error('input data has an invalid length');
    }

    const parser = getParser(type);
    return parser.decode(value, buffer, type);
  });
};

exports.unpack = unpack;
//# sourceMappingURL=array.js.map