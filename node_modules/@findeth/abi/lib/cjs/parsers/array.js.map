{"version":3,"sources":["../../../src/parsers/array.ts"],"names":["ARRAY_REGEX","isArray","type","test","getType","match","encodeArray","buffer","values","Error","actualType","length","arrayBuffer","pack","Array","fill","decodeArray","value","pointer","Number","subarray","arrayPointer","unpack","parsers","address","encode","encodeAddress","decode","decodeAddress","array","dynamic","bytes","encodeBytes","decodeBytes","fixedBytes","encodeFixedBytes","decodeFixedBytes","number","encodeNumber","decodeNumber","string","encodeString","decodeString","getParser","types","staticBuffer","packedStaticBuffer","dynamicBuffer","packedDynamicBuffer","updateFunctions","packedUpdateFunctions","reduce","index","parser","offset","staticOffset","newStaticBuffer","Buffer","alloc","newDynamicBuffer","update","oldBuffer","newBuffer","Uint8Array","updatedStaticBuffer","target","iterate","chunkSize","i","slice","iterator","map","done","next"],"mappings":"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","sourcesContent":["import { concat, concatMultiple, toBuffer, toNumber } from '../utils/buffer';\nimport { decodeAddress, encodeAddress } from './address';\nimport { decodeBytes, encodeBytes } from './bytes';\nimport { decodeFixedBytes, encodeFixedBytes, isFixedBytes } from './fixed-bytes';\nimport { decodeNumber, encodeNumber, isNumber } from './number';\nimport { DecodeFunction, EncodeFunction, Parser } from './parser';\nimport { decodeString, encodeString } from './string';\n\nconst ARRAY_REGEX = /^(.*)\\[]$/;\n\n/**\n * Check if a type is an array type.\n *\n * @param {string} type\n * @return {boolean}\n */\nexport const isArray = (type: string): boolean => {\n  return ARRAY_REGEX.test(type);\n};\n\n/**\n * Get the \"inner\" type for an array type. E.g. `getType(\"uint256[]\")` -> uint256.\n *\n * @param {string} type\n * @return {string}\n */\nexport const getType = (type: string): string => {\n  return type.match(ARRAY_REGEX)![1];\n};\n\nexport const encodeArray: EncodeFunction = (buffer: Uint8Array, values: unknown[], type: string): Uint8Array => {\n  if (!isArray(type)) {\n    throw new Error('Invalid type: type is not array');\n  }\n\n  const actualType = getType(type);\n  const length = toBuffer(values.length);\n\n  const arrayBuffer = concat(buffer, length);\n\n  return pack(arrayBuffer, values, new Array(values.length).fill(actualType));\n};\n\nexport const decodeArray: DecodeFunction = (value: Uint8Array, buffer: Uint8Array, type: string): unknown[] => {\n  if (!isArray(type)) {\n    throw new Error('Invalid type: type is not array');\n  }\n\n  const actualType = getType(type);\n  const pointer = Number(toNumber(value));\n  const length = Number(toNumber(buffer.subarray(pointer, pointer + 32)));\n\n  const arrayPointer = pointer + 32;\n  const arrayBuffer = buffer.subarray(arrayPointer);\n\n  return unpack(arrayBuffer, new Array(length).fill(actualType));\n};\n\n/**\n * All available parsers.\n */\nconst parsers: Record<string, Parser> = {\n  address: {\n    encode: encodeAddress,\n    decode: decodeAddress\n  },\n  array: {\n    dynamic: true,\n    encode: encodeArray,\n    decode: decodeArray\n  },\n  bytes: {\n    dynamic: true,\n    encode: encodeBytes,\n    decode: decodeBytes\n  },\n  fixedBytes: {\n    encode: encodeFixedBytes,\n    decode: decodeFixedBytes\n  },\n  number: {\n    encode: encodeNumber,\n    decode: decodeNumber\n  },\n  string: {\n    dynamic: true,\n    encode: encodeString,\n    decode: decodeString\n  }\n};\n\n/**\n * Get a parser for a type. Throws an error if the parser could not be found.\n *\n * @param {string} type\n * @return {Parser}\n */\nexport const getParser = (type: string): Parser => {\n  if (parsers[type]) {\n    return parsers[type];\n  }\n\n  // bytes[n]\n  if (isFixedBytes(type)) {\n    return parsers.fixedBytes;\n  }\n\n  // u?int[n], bool\n  if (isNumber(type) || type === 'bool') {\n    return parsers.number;\n  }\n\n  // type[]\n  if (isArray(type)) {\n    return parsers.array;\n  }\n\n  throw new Error(`type \"${type}\" is not supported`);\n};\n\ninterface PackState {\n  staticBuffer: Uint8Array;\n  dynamicBuffer: Uint8Array;\n  updateFunctions: Array<(buffer: Uint8Array) => Uint8Array>;\n}\n\n/**\n * Pack multiple values into a single Buffer, based on the provided types. Returns a new buffer with the\n * packed values.\n *\n * Based on the implementation of Ethers.js:\n * https://github.com/ethers-io/ethers.js/blob/fa87417e9416d99a37d9a2668a1e54feb7e342fc/packages/abi/src.ts/coders/array.ts\n *\n * @param {Buffer} buffer\n * @param {any[]} values\n * @param {string[]} types\n * @return {Buffer}\n */\nexport const pack = (buffer: Uint8Array, values: unknown[], types: string[]): Uint8Array => {\n  const {\n    staticBuffer: packedStaticBuffer,\n    dynamicBuffer: packedDynamicBuffer,\n    updateFunctions: packedUpdateFunctions\n  } = types.reduce<PackState>(\n    ({ staticBuffer, dynamicBuffer, updateFunctions }, type, index) => {\n      const parser = getParser(type);\n      const value = values[index];\n\n      if (parser.dynamic) {\n        const offset = dynamicBuffer.length;\n        const staticOffset = staticBuffer.length;\n\n        const newStaticBuffer = concat(staticBuffer, Buffer.alloc(32, 0));\n        const newDynamicBuffer = parser.encode(dynamicBuffer, value, type);\n\n        const update = (oldBuffer: Uint8Array): Uint8Array => {\n          return concatMultiple([\n            oldBuffer.subarray(0, staticOffset),\n            toBuffer(oldBuffer.length + offset),\n            oldBuffer.subarray(staticOffset + 32)\n          ]);\n        };\n\n        return {\n          staticBuffer: newStaticBuffer,\n          dynamicBuffer: newDynamicBuffer,\n          updateFunctions: [...updateFunctions, update]\n        };\n      }\n\n      const newBuffer = parser.encode(staticBuffer, value, type);\n\n      return { staticBuffer: newBuffer, dynamicBuffer, updateFunctions };\n    },\n    { staticBuffer: new Uint8Array(0), dynamicBuffer: new Uint8Array(0), updateFunctions: [] }\n  );\n\n  const updatedStaticBuffer = packedUpdateFunctions.reduce<Uint8Array>(\n    (target, update) => update(target),\n    packedStaticBuffer\n  );\n\n  return concatMultiple([buffer, updatedStaticBuffer, packedDynamicBuffer]);\n};\n\n/**\n * Iterate over a `Buffer` with provided `chunkSize`.\n *\n * @param {Buffer} buffer\n * @param {number} chunkSize\n * @return {Generator<Buffer, Buffer, void>}\n */\nexport function* iterate(buffer: Uint8Array, chunkSize: number): Generator<Uint8Array, Uint8Array, void> {\n  for (let i = 0; i < buffer.length; i += chunkSize) {\n    yield buffer.slice(i, i + chunkSize);\n  }\n\n  return buffer;\n}\n\nexport const unpack = (buffer: Uint8Array, types: string[]): unknown[] => {\n  const iterator = iterate(buffer, 32);\n\n  return types.map((type) => {\n    const { value, done } = iterator.next();\n    if (done) {\n      throw new Error('input data has an invalid length');\n    }\n\n    const parser = getParser(type);\n    return parser.decode(value, buffer, type);\n  });\n};\n"],"file":"array.js"}