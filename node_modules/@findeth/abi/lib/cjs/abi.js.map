{"version":3,"sources":["../../src/abi.ts"],"names":["encode","input","values","types","map","type","Buffer","alloc","encodeWithIdentifier","contractFunction","identifier","from","encoded","inputs","decode","buffer"],"mappings":";;;;;;;AACA;;AACA;;AACA;;AASO,MAAMA,MAAM,GAAG,CAACC,KAAD,EAAuCC,MAAvC,KAAyE;AAC7F,QAAMC,KAAK,GAAGF,KAAK,CAACG,GAAN,CAAWC,IAAD,IAAU;AAChC,QAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC5B,aAAOA,IAAP;AACD;;AAED,WAAOA,IAAI,CAACA,IAAZ;AACD,GANa,CAAd;AAQA,SAAO,iBAAKC,MAAM,CAACC,KAAP,CAAa,CAAb,CAAL,EAAsBL,MAAtB,EAA8BC,KAA9B,CAAP;AACD,CAVM;;;;AAmBA,MAAMK,oBAAoB,GAAG,CAACC,gBAAD,EAAqCP,MAArC,KAAuE;AACzG,QAAMQ,UAAU,GAAGJ,MAAM,CAACK,IAAP,CAAY,+BAAcF,gBAAd,CAAZ,EAA6C,KAA7C,CAAnB;AACA,QAAMG,OAAO,GAAGZ,MAAM,CAACS,gBAAgB,CAACI,MAAlB,EAA0BX,MAA1B,CAAtB;AAEA,SAAO,oBAAOQ,UAAP,EAAmBE,OAAnB,CAAP;AACD,CALM;;;;AAOA,MAAME,MAAM,GAAG,CAAsBb,KAAtB,EAA4Dc,MAA5D,KAAkF;AACtG,QAAMZ,KAAK,GAAGF,KAAK,CAACG,GAAN,CAAWC,IAAD,IAAU;AAChC,QAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC5B,aAAOA,IAAP;AACD;;AAED,WAAOA,IAAI,CAACA,IAAZ;AACD,GANa,CAAd;AAQA,SAAO,mBAAOU,MAAP,EAAeZ,KAAf,CAAP;AACD,CAVM","sourcesContent":["import { ContractFunction, ContractInput } from './contract';\nimport { getIdentifier } from './identifier';\nimport { pack, unpack } from './parsers/array';\nimport { concat } from './utils/buffer';\n\n/**\n * Encode the input data with the provided types.\n *\n * @param {(ContractInput | string)[]} input\n * @param {unknown[]} values\n * @return {Buffer}\n */\nexport const encode = (input: Array<ContractInput | string>, values: unknown[]): Uint8Array => {\n  const types = input.map((type) => {\n    if (typeof type === 'string') {\n      return type;\n    }\n\n    return type.type;\n  });\n\n  return pack(Buffer.alloc(0), values, types);\n};\n\n/**\n * Encode the input data with the provided types, and prepend the function identifier.\n *\n * @param {ContractFunction} contractFunction\n * @param {unknown[]} values\n * @return {Buffer}\n */\nexport const encodeWithIdentifier = (contractFunction: ContractFunction, values: unknown[]): Uint8Array => {\n  const identifier = Buffer.from(getIdentifier(contractFunction), 'hex');\n  const encoded = encode(contractFunction.inputs, values);\n\n  return concat(identifier, encoded);\n};\n\nexport const decode = <T extends unknown[]>(input: Array<ContractInput | string>, buffer: Buffer): T => {\n  const types = input.map((type) => {\n    if (typeof type === 'string') {\n      return type;\n    }\n\n    return type.type;\n  });\n\n  return unpack(buffer, types) as T;\n};\n"],"file":"abi.js"}